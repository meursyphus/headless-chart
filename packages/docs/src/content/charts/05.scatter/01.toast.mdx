---
nav_group: "Scatter"
nav_order: 1
title: "Toast"
description: "A headless-chart example inspired by Toast Chart using the same color scheme"
image: /scatter-chart/toast.png
files:
  App.js: |
    import Widget from "@meursyphus/flitter-react";
    import { ScatterChart } from "@meursyphus/headless-chart";
    import {
      Text,
      BoxDecoration,
      Container,
      EdgeInsets,
      Row,
      SizedBox,
      TextStyle,
      Padding,
      MainAxisSize,
      Stack,
      Positioned,
    } from "@meursyphus/flitter";

    import defaultColors from "./colors";
    import Scatter from "./Scatter";
    import YAxis from "./YAxis";
    import XAxis from "./XAxis";

    const data = {
      datasets: [
        {
          legend: 'Africa',
          data: [
            { x: 4200, y: 70.35, label: 'Morocco' },
            { x: 4200, y: 70.71, label: 'Egypt' },
            { x: 5900, y: 56.46, label: 'Gabon' },
            { x: 6600, y: 72.74, label: 'Algeria' },
            { x: 6700, y: 76.28, label: 'Libya' },
            { x: 7100, y: 74.66, label: 'Tunisia' },
            { x: 10500, y: 69.28, label: 'Trinidad and Tobago' },
            { x: 12800, y: 72.09, label: 'Mauritius' },
            { x: 18200, y: 78.68, label: 'Malta' }
          ]
        },
        {
          legend: 'America',
          data: [
            { x: 4800, y: 74.64, label: 'Paraguay' },
            { x: 4900, y: 70.92, label: 'El Salvador' },
            { x: 5600, y: 69.22, label: 'Peru' },
            { x: 5800, y: 74.06, label: 'Venezuela' },
            { x: 6300, y: 67.63, label: 'Dominican Republic' },
            { x: 6500, y: 67.43, label: 'Belize' },
            { x: 6600, y: 71.43, label: 'Colombia' },
            { x: 6900, y: 72.14, label: 'Panama' },
            { x: 8100, y: 71.41, label: 'Brazil' },
            { x: 9600, y: 76.63, label: 'Costa Rica' },
            { x: 9600, y: 74.94, label: 'Mexico' },
            { x: 12400, y: 75.7, label: 'Argentina' },
            { x: 14500, y: 75.92, label: 'Uruguay' },
            { x: 16400, y: 71.64, label: 'Barbados' },
            { x: 17700, y: 65.63, label: 'Bahamas, The' },
            { x: 17700, y: 77.49, label: 'Puerto Rico' },
            { x: 31500, y: 79.96, label: 'Canada' },
            { x: 32100, y: 77.43, label: 'United States' }
          ]
        },
        {
          legend: 'Asia',
          data: [
            { x: 5600, y: 71.96, label: 'China' },
            { x: 5700, y: 61.29, label: 'Turkmenistan' },
            { x: 7700, y: 69.66, label: 'Iran' },
            { x: 7800, y: 66.07, label: 'Kazakhstan' },
            { x: 8100, y: 71.41, label: 'Thailand' },
            { x: 9700, y: 71.95, label: 'Malaysia' },
            { x: 12000, y: 75.23, label: 'Saudi Arabia' },
            { x: 13100, y: 72.85, label: 'Oman' },
            { x: 19200, y: 75.58, label: 'Korea, South' },
            { x: 19200, y: 73.98, label: 'Bahrain' },
            { x: 20800, y: 79.17, label: 'Israel' },
            { x: 21300, y: 76.84, label: 'Kuwait' },
            { x: 23200, y: 73.4, label: 'Qatar' },
            { x: 25200, y: 74.99, label: 'United Arab Emirates' },
            { x: 25300, y: 77.06, label: 'Taiwan' },
            { x: 27800, y: 81.53, label: 'Singapore' },
            { x: 29400, y: 81.04, label: 'Japan' },
            { x: 34200, y: 81.39, label: 'Hong Kong' }
          ]
        },
        {
          legend: 'Europe',
          data: [
            { x: 7700, y: 71.12, label: 'Romania' },
            { x: 8200, y: 71.75, label: 'Bulgaria' },
            { x: 9800, y: 66.39, label: 'Russia' },
            { x: 10700, y: 76.38, label: 'Chile' },
            { x: 11200, y: 74.14, label: 'Croatia' },
            { x: 11500, y: 70.86, label: 'Latvia' },
            { x: 12000, y: 74.16, label: 'Poland' },
            { x: 12500, y: 73.46, label: 'Lithuania' },
            { x: 14300, y: 71.38, label: 'Estonia' },
            { x: 14500, y: 74.19, label: 'Slovakia' },
            { x: 14900, y: 72.25, label: 'Hungary' },
            { x: 16800, y: 75.78, label: 'Czech Republic' },
            { x: 17900, y: 77.35, label: 'Portugal' },
            { x: 19600, y: 75.93, label: 'Slovenia' },
            { x: 21300, y: 78.94, label: 'Greece' },
            { x: 23300, y: 79.37, label: 'Spain' },
            { x: 27700, y: 79.54, label: 'Italy' },
            { x: 28400, y: 80.3, label: 'Sweden' },
            { x: 28700, y: 78.54, label: 'Germany' },
            { x: 28700, y: 79.44, label: 'France' },
            { x: 29000, y: 78.24, label: 'Finland' },
            { x: 29500, y: 78.68, label: 'Netherlands' },
            { x: 29600, y: 78.27, label: 'United Kingdom' },
            { x: 30600, y: 78.44, label: 'Belgium' },
            { x: 31300, y: 78.87, label: 'Austria' },
            { x: 31900, y: 77.36, label: 'Ireland' },
            { x: 31900, y: 80.18, label: 'Iceland' },
            { x: 32200, y: 77.44, label: 'Denmark' },
            { x: 33800, y: 80.31, label: 'Switzerland' }
          ]
        },
        {
          legend: 'Oceania',
          data: [
            { x: 2200, y: 64.56, label: 'Papua New Guinea' },
            { x: 2700, y: 61.32, label: 'Kiribati' },
            { x: 5900, y: 69.2, label: 'Fiji' },
            { x: 14500, y: 78.75, label: 'Virgin Islands' },
            { x: 23200, y: 78.49, label: 'New Zealand' },
            { x: 30700, y: 80.26, label: 'Australia' }
          ]
        }
      ]
    };

    // 숫자를 k단위로 줄여주는 함수
    function formatNumberToK(num) {
      if (num >= 1000) {
        const kValue = (num / 1000).toFixed(1).replace(/\.0$/, "");
        return kValue + "k";
      }
      return num.toString();
    }

    const chart = ScatterChart({
      data,
      custom: {
        layout: ({ title, legends, plot }) =>
          Container({
            padding: EdgeInsets.only({ left: 70, bottom: 50, right: 30, top: 30 }),
            child: Stack({
              children: [
                Positioned({
                  top: -20,
                  right: 0,
                  child: Text("Toast Chart Example", {
                    style: new TextStyle({
                      fontSize: 14,
                      color: "#999999",
                      fontFamily: "Noto Sans JP",
                    }),
                  }),
                }),
                plot,
              ],
            }),
          }),

        xAxis: ({ line, labels, tick }) => {
          // AnimatedXAxis 사용
          return new XAxis({ line, labels, tick });
        },
        yAxis: ({ line, labels, tick }) => {
          return new YAxis({ line, labels, tick });
        },

        xAxisLabel: ({ name }) =>
          Padding({
            padding: EdgeInsets.only({ top: 1 }),
            child: Text(name, {
              style: new TextStyle({
                fontFamily: "Noto Sans JP",
                fontSize: 10,
                color: "#666666",
              }),
            }),
          }),

        yAxisLabel: ({ name }) =>
          Padding({
            padding: EdgeInsets.only({ right: 1 }),
            child: Text(name, {
              style: new TextStyle({
                fontFamily: "Noto Sans JP",
                fontSize: 10,
                color: "#666666",
              }),
            }),
          }),

        xAxisTick: () =>
          Container({
            height: 6,
            width: 1,
            color: "#DDDDDD",
          }),

        yAxisTick: () =>
          Container({
            height: 1,
            width: 6,
            color: "#DDDDDD",
          }),

        xAxisLine: () =>
          Container({
            color: "#BBBBBB",
            width: Infinity,
            height: 1,
          }),

        yAxisLine: () =>
          Container({
            color: "#BBBBBB",
            width: 1,
            height: Infinity,
          }),

        legend: ({ name }) => {
          const legendIndex = data.datasets.findIndex(d => d.legend === name);
          const color = defaultColors[legendIndex % defaultColors.length];
          return Padding({
            padding: EdgeInsets.symmetric({ horizontal: 8 }),
            child: Row({
              mainAxisSize: MainAxisSize.min,
              children: [
                Container({
                  width: 12,
                  height: 12,
                  decoration: new BoxDecoration({
                    color: color,
                    borderRadius: 6,
                  }),
                }),
                SizedBox({ width: 4 }),
                Text(name, {
                  style: new TextStyle({
                    fontFamily: "Noto Sans JP",
                    fontSize: 12,
                    color: "#666666",
                  }),
                }),
              ],
            }),
          });
        },

        scatter: ({  label, legend, index }, { scale }) => {
          const legendIndex = index;
          return new Scatter({ label, legend, index, scale, });
        },

        dataLabel: () => SizedBox.shrink(),

        gridXLine: () => Container({ height: 1, color: "#EEEEEE" }),
        gridYLine: () => Container({ width: 1, color: "#EEEEEE" }),

        xAxisLabel: ({ name }) =>
          Padding({
            padding: EdgeInsets.only({ top: 1 }),
            child: Text(formatNumberToK(parseFloat(name)), {
              style: new TextStyle({
                fontFamily: "Noto Sans JP",
                fontSize: 10,
                color: "#666666",
              }),
            }),
          }),
      },
    });

    export default function App() {
      return <Widget
        width="auto"
        height="500px"
        widget={chart}
        renderer="svg"
      />
    }

  Scatter.js: |
    import { Transform, CustomPaint, Path, Rect, Offset, StatefulWidget, State,  Animation, AnimationController, CurvedAnimation, Curves, Tween } from "@meursyphus/flitter";
    import defaultColors from "./colors";

    const SHAPES = ["circle", "star", "square", "triangle"];

    function Scatter({
      color,
      shape = "circle",
      size = 8,
    }) {
      return CustomPaint({
        painter: {
          svg: {
            createDefaultSvgEl: (context) => {
              return {
                scatter: context.createSvgEl("path"),
              };
            },
            paint: ({ scatter }) => {
              const path = createShapePath({ shape, size });
              scatter.setAttribute("fill", "none");
              scatter.setAttribute("stroke", color);
              scatter.setAttribute("stroke-width", "1");
              scatter.setAttribute("d", path.getD());
            },
          },
        },
      });
    }

    function createShapePath({
      shape,
      size,
    }) {
      const path = new Path();
      const halfSize = size / 2;

      switch (shape) {
        case "circle": {
          path.addOval(Rect.fromCircle({ center: new Offset({ x: 0, y: 0 }), radius: halfSize }));
          break;
        }
        case "star": {
          const outerRadius = halfSize;
          const innerRadius = halfSize * 0.4;
          const points = 5;
          
          for (let i = 0; i < points * 2; i++) {
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const angle = (i * Math.PI) / points;
            const px = radius * Math.sin(angle);
            const py = -radius * Math.cos(angle);
            
            if (i === 0) {
              path.moveTo({ x: px, y: py });
            } else {
              path.lineTo({ x: px, y: py });
            }
          }
          path.close();
          break;
        }
        case "square": {
          path.moveTo({ x: -halfSize, y: -halfSize });
          path.lineTo({ x: halfSize, y: -halfSize });
          path.lineTo({ x: halfSize, y: halfSize });
          path.lineTo({ x: -halfSize, y: halfSize });
          path.close();
          break;
        }
        case "triangle": {
          const height = size * Math.sqrt(3) / 2;
          path.moveTo({ x: 0, y: -halfSize });
          path.lineTo({ x: halfSize, y: height/2 });
          path.lineTo({ x: -halfSize, y: height/2 });
          path.close();
          break;
        }
      }

      return path;
    }


    class AnimatedScatter extends StatefulWidget {
      label;
      legend;
      index;
      scale;

      constructor({ label, legend, index, scale }) {
        super();
        this.label = label;
        this.legend = legend;
        this.index = index;
        this.scale = scale;
      }

      createState() {
        return new AnimatedScatterState();
      }
    }

    class AnimatedScatterState extends State {
      initState(context) {
        this.animationController = new AnimationController({ duration: 300 });
        this.animationController.addListener(() => {
          this.setState();
        });
        const tween = new Tween({ begin: 0, end: 1 });
        this.scaleAnimation = tween.animated(
          new CurvedAnimation({
            parent: this.animationController,
            curve: Curves.easeInOut,
          })
        );
        this.animationController.forward();
      }

      build(context) {
        const { index } = this.widget;
        const color = defaultColors[index % defaultColors.length];
        const shape = SHAPES[index % SHAPES.length];
        
        return Transform.scale({
          scale: this.scaleAnimation.value,
          child: Scatter({
            color,
            shape,
            size: 8,
          }),
        });
      }
    }

    export default AnimatedScatter;

  XAxis.js: |
    import {
      Container,
      Row,
      Column,
      StatefulWidget,
      State,
      AnimationController,
      CurvedAnimation,
      Curves,
      ConstraintsTransformBox,
      Alignment,
      FractionallySizedBox,
      MainAxisSize,
      MainAxisAlignment,
      CrossAxisAlignment,
      SizedBox,
      Tween,
      FractionalTranslation,
      Offset,
    } from "@meursyphus/flitter";

    function IgnoreChildWidth({ child, isEdge = false }) {
      return Container({
        width: 0,
        child: ConstraintsTransformBox({
          constraintsTransform: ConstraintsTransformBox.unconstrained,
          alignment: isEdge ? Alignment.centerRight : Alignment.center,
          child,
        }),
      });
    }

    class XAxis extends StatefulWidget {
      constructor({ line, labels, tick }) {
        super();
        this.line = line;
        this.labels = labels;
        this.tick = tick;
      }

      createState() {
        return new XAxisState();
      }
    }

    class XAxisState extends State {
      initState(context) {
        this.animationController = new AnimationController({ duration: 300 });
        this.animationController.addListener(() => {
          this.setState();
        });
        const tween = new Tween({ begin: 0, end: 1 });
        this.tweenAnimation = tween.animated(
          new CurvedAnimation({
            parent: this.animationController,
            curve: Curves.easeInOut,
          })
        );
        this.animationController.forward();
      }

      build(context) {
        const { line, labels, tick } = this.widget;

        const HorizontalLine = () => line;

        const Labels = () =>
          FractionallySizedBox({
            widthFactor: this.tweenAnimation.value,
            alignment: Alignment.centerRight,
            child: Row({
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: labels.map((label) =>
                IgnoreChildWidth({ child: label })
              ),
            }),
          });

        const Ticks = () =>
          FractionallySizedBox({
            widthFactor: this.tweenAnimation.value,
            alignment: Alignment.centerRight,
            child: Row({
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: Array(labels.length).fill(0).map((_, index) => 
                FractionalTranslation({
                  translation: new Offset({ x: index === 0 ? -1 : 0, y: 0 }),
                  child: tick
                })
              ),
            }),
          });

        return Column({
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            HorizontalLine(),
            Ticks(),
            SizedBox({ height: 8 }),
            Labels(),
          ],
        });
      }
    }

    export default XAxis;


  YAxis.js: |
    import {
      Container,
      Column,
      Row,
      Text,
      TextStyle,
      EdgeInsets,
      StatefulWidget,
      State,
      AnimationController,
      CurvedAnimation,
      Curves,
      Transform,
      Offset,
      Opacity,
      ConstraintsTransformBox,
      Alignment,
      FractionallySizedBox,
      FractionalTranslation,
      MainAxisSize,
      MainAxisAlignment,
      CrossAxisAlignment,
      SizedBox,
      Tween,
      VerticalDirection,
    } from "@meursyphus/flitter";

    function IgnoreHeight({ child, isEdge = false }) {
      return Container({
        height: 0,
        child: ConstraintsTransformBox({
          constraintsTransform: ConstraintsTransformBox.unconstrained,
          alignment: isEdge ? Alignment.bottomCenter : Alignment.center,
          child,
        }),
      });
    }

    class YAxis extends StatefulWidget {
      constructor({ line, labels, tick }) {
        super();
        this.line = line;
        this.labels = labels;
        this.tick = tick;
      }

      createState() {
        return new YAxisState();
      }
    }

    class YAxisState extends State {
      initState(context) {
        this.animationController = new AnimationController({ duration: 300 });
        this.animationController.addListener(() => {
          this.setState();
        });
        const tween = new Tween({ begin: 0, end: 1 });
        this.tweenAnimation = tween.animated(
          new CurvedAnimation({
            parent: this.animationController,
            curve: Curves.easeInOut,
          })
        );
        this.animationController.forward();
      }

      build(context) {
        const { line, labels, tick } = this.widget;
    
        const VerticalLine = () => line;

        const Labels = () =>
          FractionallySizedBox({
            heightFactor: this.tweenAnimation.value,
            alignment: Alignment.bottomCenter,
            child: Column({
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              crossAxisAlignment: CrossAxisAlignment.end,
              verticalDirection: VerticalDirection.up,
              children: labels.map((label) =>
                IgnoreHeight({ child: label })
              ),
            }),
          });

        const Ticks = () =>
          FractionallySizedBox({
            heightFactor: this.tweenAnimation.value,
            alignment: Alignment.bottomCenter,
            child: Column({
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: Array(labels.length).fill(0).map((_, index) => 
                FractionalTranslation({
                  translation: new Offset({ x: 0, y: index === (labels.length - 1) ? 1 : 0 }),
                  child: tick
                })
              ),
            }),
          });

        return Row({
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            Labels(),
            SizedBox({ width: 8 }),
            Ticks(),
            VerticalLine(),
          ],
        });
      }
    }

    export default YAxis;

  colors.js: |
    const defaultColors = [
      "#00a9ff",
      "#ffb840",
      "#ff5a46",
      "#00bd9f",
      "#785fff",
      "#f28b8c",
      "#989486",
      "#516f7d",
      "#28e6eb",
      "#28695f",
      "#96c85a",
      "#45ba3f",
      "#295ba0",
      "#2a4175",
      "#289399",
      "#66c8d3",
      "#617178",
      "#8a9a9a",
      "#bebebe",
      "#374b5a",
      "#64eba0",
      "#ffe155",
      "#ff9141",
      "#af4beb",
      "#ff73fa",
      "#ff55b2",
      "#2869f5",
      "#3296ff",
      "#8cc3ff",
      "#2828b9",
      "#fa8787",
      "#e13782",
      "#7d5aaa",
      "#643c91",
      "#d25f5f",
      "#fabe6e",
      "#c3a9eb",
      "#b9c8f5",
      "#73a0cd",
      "#0f5a8c",
    ];
    export default defaultColors;
---

# Scatter Chart Example

A headless-chart example inspired by Toast UI Chart.