---
nav_group: "차트 가이드"
nav_order: 2
title: "Line Chart"
description: "라인 차트 생성 및 커스터마이징 가이드"
---

# Line Chart

라인 차트는 시간에 따른 데이터의 변화를 표현하는데 최적화된 차트입니다. 추세, 패턴, 연속성을 시각적으로 보여줍니다.

## 기본 사용법

### 간단한 예제

```javascript
import Widget from '@meursyphus/flitter-react';
import { LineChart } from '@meursyphus/headless-chart';

const data = {
  labels: ['1월', '2월', '3월', '4월', '5월', '6월'],
  datasets: [{
    legend: '방문자 수',
    values: [1200, 1900, 3000, 2500, 4200, 3800]
  }]
};

function BasicLineChart() {
  return (
    <Widget 
      width="600px" 
      height="400px" 
      widget={LineChart({ data })} 
    />
  );
}
```

### 다중 라인

여러 데이터를 비교할 때:

```javascript
const data = {
  labels: ['월', '화', '수', '목', '금', '토', '일'],
  datasets: [
    {
      legend: '웹사이트',
      values: [3000, 3200, 2800, 3500, 4000, 4200, 3800]
    },
    {
      legend: '모바일 앱',
      values: [1500, 1700, 1600, 2000, 2300, 2500, 2200]
    },
    {
      legend: 'API',
      values: [500, 600, 550, 700, 800, 850, 750]
    }
  ]
};
```

## API 참조

### Props 인터페이스

```typescript
interface LineChartProps {
  // 필수
  data: LineChartData;
  
  // 선택
  custom?: Partial<LineChartCustom>;
  title?: string;
  getScale?: (data: LineChartData) => LineChartScale;
}

// 커스텀 컴포넌트 타입
type LineChartCustom = {
  line: ({ values, legend, index }) => Widget;
  series: ({ lines }) => Widget;
  // ... 기타 공통 컴포넌트
};
```

## 라인 스타일링

### 1. 기본 라인 커스터마이징

```javascript
import { Path, Paint, StrokeCap, StrokeJoin } from '@meursyphus/flitter';

const chart = LineChart({
  data,
  custom: {
    line: ({ values, legend, index }) => {
      const colors = ['#3b82f6', '#10b981', '#f59e0b'];
      const strokeWidths = [2, 3, 2];
      
      // 라인 경로 생성 (실제로는 더 복잡한 계산 필요)
      const path = createLinePath(values);
      
      return CustomPaint({
        painter: {
          paint: (canvas, size) => {
            const paint = new Paint({
              color: colors[index % colors.length],
              strokeWidth: strokeWidths[index % strokeWidths.length],
              style: PaintingStyle.stroke,
              strokeCap: StrokeCap.round,
              strokeJoin: StrokeJoin.round
            });
            
            canvas.drawPath(path, paint);
          }
        }
      });
    }
  }
});
```

### 2. 점선 스타일

```javascript
const dashedLine = ({ values, index }) => {
  const colors = ['#3b82f6', '#ef4444', '#10b981'];
  
  return CustomPaint({
    painter: {
      paint: (canvas, size) => {
        const paint = new Paint({
          color: colors[index % colors.length],
          strokeWidth: 2,
          style: PaintingStyle.stroke,
          // 점선 패턴: 10px 선, 5px 공백
          dashPattern: [10, 5]
        });
        
        // 라인 그리기
        drawLine(canvas, values, paint);
      }
    }
  });
};
```

### 3. 곡선 라인

```javascript
const smoothLine = ({ values }) => {
  return CustomPaint({
    painter: {
      paint: (canvas, size) => {
        const paint = new Paint({
          color: '#3b82f6',
          strokeWidth: 2,
          style: PaintingStyle.stroke
        });
        
        // 베지어 곡선으로 부드러운 라인 생성
        const path = createSmoothPath(values);
        canvas.drawPath(path, paint);
      }
    }
  });
};

// 베지어 곡선 경로 생성 함수
function createSmoothPath(values) {
  const path = new Path();
  const points = calculatePoints(values);
  
  path.moveTo(points[0].x, points[0].y);
  
  for (let i = 1; i < points.length; i++) {
    const cp1 = controlPoint(points[i - 1], points[i]);
    const cp2 = controlPoint(points[i], points[i - 1]);
    
    path.cubicTo(
      cp1.x, cp1.y,
      cp2.x, cp2.y,
      points[i].x, points[i].y
    );
  }
  
  return path;
}
```

### 4. 데이터 포인트 추가

```javascript
const lineWithPoints = ({ values, index }) => {
  const colors = ['#3b82f6', '#10b981', '#f59e0b'];
  const color = colors[index % colors.length];
  
  return Stack({
    children: [
      // 라인
      CustomPaint({
        painter: createLinePainter(values, color)
      }),
      // 데이터 포인트
      ...values.map((value, i) => 
        Positioned({
          left: calculateX(i),
          top: calculateY(value),
          child: Container({
            width: 8,
            height: 8,
            decoration: new BoxDecoration({
              shape: BoxShape.circle,
              color: '#ffffff',
              border: Border.all({ color, width: 2 })
            })
          })
        })
      )
    ]
  });
};
```

## 영역 채우기

### 그라데이션 영역

```javascript
const areaLine = ({ values, index }) => {
  const colors = [
    { line: '#3b82f6', fill: 'rgba(59, 130, 246, 0.1)' },
    { line: '#10b981', fill: 'rgba(16, 185, 129, 0.1)' }
  ];
  
  const { line: lineColor, fill: fillColor } = colors[index % colors.length];
  
  return Stack({
    children: [
      // 영역 채우기
      CustomPaint({
        painter: {
          paint: (canvas, size) => {
            const fillPaint = new Paint({
              color: fillColor,
              style: PaintingStyle.fill
            });
            
            const areaPath = createAreaPath(values);
            canvas.drawPath(areaPath, fillPaint);
          }
        }
      }),
      // 라인
      CustomPaint({
        painter: createLinePainter(values, lineColor)
      })
    ]
  });
};
```

## 인터랙티브 기능

### 1. 호버 효과

```javascript
import { MouseRegion } from '@meursyphus/flitter';
import { useState } from 'react';

function InteractiveLineChart() {
  const [hoveredPoint, setHoveredPoint] = useState(null);
  
  const chart = LineChart({
    data,
    custom: {
      line: ({ values, legend, index }) => {
        return Stack({
          children: [
            // 기본 라인
            createBaseLine(values, index),
            // 인터랙티브 포인트
            ...values.map((value, i) => {
              const key = `${legend}-${i}`;
              const isHovered = hoveredPoint === key;
              
              return Positioned({
                left: calculateX(i),
                top: calculateY(value),
                child: MouseRegion({
                  onEnter: () => setHoveredPoint(key),
                  onExit: () => setHoveredPoint(null),
                  cursor: 'pointer',
                  child: Container({
                    width: isHovered ? 12 : 8,
                    height: isHovered ? 12 : 8,
                    decoration: new BoxDecoration({
                      shape: BoxShape.circle,
                      color: '#ffffff',
                      border: Border.all({ 
                        color: getColor(index), 
                        width: 2 
                      }),
                      boxShadow: isHovered ? [{
                        color: 'rgba(0, 0, 0, 0.2)',
                        blurRadius: 4,
                        offset: { x: 0, y: 2 }
                      }] : []
                    })
                  })
                })
              });
            })
          ]
        });
      }
    }
  });
  
  return (
    <>
      <Widget width="100%" height="400px" widget={chart} />
      {hoveredPoint && (
        <div>선택된 포인트: {hoveredPoint}</div>
      )}
    </>
  );
}
```

### 2. 툴팁

```javascript
const lineWithTooltip = ({ values, legend }) => {
  return Stack({
    children: [
      createBaseLine(values),
      ...values.map((value, i) => 
        Positioned({
          left: calculateX(i),
          top: calculateY(value),
          child: Tooltip({
            message: `${legend}: ${value}`,
            child: Container({
              width: 8,
              height: 8,
              decoration: new BoxDecoration({
                shape: BoxShape.circle,
                color: '#3b82f6'
              })
            })
          })
        })
      )
    ]
  });
};
```

## 실전 예제

### 1. 실시간 차트

```javascript
function RealtimeLineChart() {
  const [data, setData] = useState({
    labels: [],
    datasets: [{ legend: 'CPU 사용률', values: [] }]
  });
  
  useEffect(() => {
    const interval = setInterval(() => {
      setData(prev => {
        const now = new Date();
        const newLabels = [...prev.labels, now.toLocaleTimeString()];
        const newValues = [...prev.datasets[0].values, Math.random() * 100];
        
        // 최근 20개 데이터만 유지
        if (newLabels.length > 20) {
          newLabels.shift();
          newValues.shift();
        }
        
        return {
          labels: newLabels,
          datasets: [{ legend: 'CPU 사용률', values: newValues }]
        };
      });
    }, 1000);
    
    return () => clearInterval(interval);
  }, []);
  
  const chart = LineChart({
    data,
    custom: {
      line: ({ values }) => AnimatedLine({ 
        values,
        duration: 1000 
      })
    }
  });
  
  return <Widget width="100%" height="300px" widget={chart} />;
}
```

### 2. 다중 Y축

```javascript
const multiAxisChart = LineChart({
  data: {
    labels: ['1월', '2월', '3월', '4월', '5월'],
    datasets: [
      { legend: '매출 (백만원)', values: [100, 120, 140, 130, 160] },
      { legend: '방문자 (천명)', values: [50, 55, 60, 58, 65] }
    ]
  },
  custom: {
    yAxis: ({ labels, line, tick }, { type }) => {
      const isSecondary = type === 'secondary';
      
      return Container({
        child: Row({
          mainAxisAlignment: isSecondary ? 
            MainAxisAlignment.end : 
            MainAxisAlignment.start,
          children: [
            Column({ children: labels }),
            SizedBox({ width: 4 }),
            line
          ]
        })
      });
    }
  }
});
```

### 3. 주식 차트 스타일

```javascript
const stockChart = LineChart({
  data: stockData,
  custom: {
    line: ({ values, legend }) => {
      const isPositive = values[values.length - 1] > values[0];
      const color = isPositive ? '#10b981' : '#ef4444';
      
      return Stack({
        children: [
          // 영역 채우기
          CustomPaint({
            painter: createGradientAreaPainter(values, color)
          }),
          // 메인 라인
          CustomPaint({
            painter: createLinePainter(values, color, 2)
          }),
          // 현재 가격 표시
          Positioned({
            right: 0,
            top: calculateY(values[values.length - 1]),
            child: Container({
              padding: EdgeInsets.symmetric({ horizontal: 8, vertical: 4 }),
              decoration: new BoxDecoration({
                color,
                borderRadius: BorderRadius.circular(4)
              }),
              child: Text(formatPrice(values[values.length - 1]), {
                style: new TextStyle({
                  color: '#ffffff',
                  fontSize: 12,
                  fontWeight: 'bold'
                })
              })
            })
          })
        ]
      });
    }
  }
});
```

## 성능 최적화

### 대용량 데이터 처리

```javascript
// 데이터 포인트 샘플링
const sampleData = (data, maxPoints = 100) => {
  if (data.labels.length <= maxPoints) return data;
  
  const step = Math.ceil(data.labels.length / maxPoints);
  
  return {
    labels: data.labels.filter((_, i) => i % step === 0),
    datasets: data.datasets.map(dataset => ({
      ...dataset,
      values: dataset.values.filter((_, i) => i % step === 0)
    }))
  };
};

// 사용
const chart = LineChart({
  data: sampleData(largeData, 50)
});
```

## 접근성

### 키보드 네비게이션

```javascript
const accessibleLine = ({ values, legend }) => {
  return Stack({
    children: [
      createBaseLine(values),
      ...values.map((value, i) => 
        Positioned({
          left: calculateX(i),
          top: calculateY(value),
          child: Semantics({
            label: `${legend} ${i + 1}번째 데이터: ${value}`,
            button: true,
            child: FocusableActionDetector({
              onFocusChange: (focused) => {
                // 포커스 시 하이라이트
              },
              child: createDataPoint(value, i)
            })
          })
        })
      )
    ]
  });
};
```

## 팁과 모범 사례

1. **데이터 밀도**: 너무 많은 데이터 포인트는 가독성을 해칠 수 있음
2. **색상 대비**: 라인들이 명확히 구분되도록 색상 선택
3. **범례 위치**: 차트를 가리지 않는 위치에 배치
4. **애니메이션**: 과도한 애니메이션은 피하고 의미 있는 곳에만 사용
5. **반응형**: 화면 크기에 따라 데이터 포인트 수 조절

## 다음 단계

Line Chart를 익혔다면, [Area Chart](./03.area-chart.mdx)로 넘어가 영역을 강조하는 차트를 만들어보세요.